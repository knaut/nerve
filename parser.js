peg = (function() {
	"use strict";

	/*
	 * Generated by PEG.js 0.9.0.
	 *
	 * http://pegjs.org/
	 */

	function peg$subclass(child, parent) {
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function peg$SyntaxError(message, expected, found, location) {
		this.message  = message;
		this.expected = expected;
		this.found    = found;
		this.location = location;
		this.name     = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
			Error.captureStackTrace(this, peg$SyntaxError);
		}
	}

	peg$subclass(peg$SyntaxError, Error);

	function peg$parse(input) {
		var options = arguments.length > 1 ? arguments[1] : {},
				parser  = this,

				peg$FAILED = {},

				peg$startRuleFunctions = { start: peg$parsestart },
				peg$startRuleFunction  = peg$parsestart,

				peg$c0 = "*",
				peg$c1 = { type: "literal", value: "*", description: "\"*\"" },
				peg$c2 = function(i, j) {return i + j.join('');},
				peg$c3 = "#",
				peg$c4 = { type: "literal", value: "#", description: "\"#\"" },
				peg$c5 = function(h) {return h.join('');},
				peg$c6 = ".",
				peg$c7 = { type: "literal", value: ".", description: "\".\"" },
				peg$c8 = function(c) {return c.join('');},
				peg$c9 = "[",
				peg$c10 = { type: "literal", value: "[", description: "\"[\"" },
				peg$c11 = /^[^\]]/,
				peg$c12 = { type: "class", value: "[^\\]]", description: "[^\\]]" },
				peg$c13 = function(b) {return b.join('');},
				peg$c14 = "]",
				peg$c15 = { type: "literal", value: "]", description: "\"]\"" },
				peg$c16 = function(a) {return a.join('');},
				peg$c17 = ":",
				peg$c18 = { type: "literal", value: ":", description: "\":\"" },
				peg$c19 = function(p) {return p.join('');},
				peg$c20 = /^[a-z]/i,
				peg$c21 = { type: "class", value: "[a-z]i", description: "[a-z]i" },
				peg$c22 = /^[a-z0-9\-]/,
				peg$c23 = { type: "class", value: "[a-z0-9-]", description: "[a-z0-9-]" },
				peg$c24 = "(",
				peg$c25 = { type: "literal", value: "(", description: "\"(\"" },
				peg$c26 = ")",
				peg$c27 = { type: "literal", value: ")", description: "\")\"" },
				peg$c28 = function(f) {return f.join('');},
				peg$c29 = /^[^)]/,
				peg$c30 = { type: "class", value: "[^\\)]", description: "[^\\)]" },
				peg$c31 = /^[A-Z]/i,
				peg$c32 = { type: "class", value: "[A-Z]i", description: "[A-Z]i" },
				peg$c33 = /^[ \t\n\r]/,
				peg$c34 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },
				peg$c35 = function() {return '';},

				peg$currPos          = 0,
				peg$savedPos         = 0,
				peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
				peg$maxFailPos       = 0,
				peg$maxFailExpected  = [],
				peg$silentFails      = 0,

				peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$savedPos, peg$currPos);
		}

		function location() {
			return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description) {
			throw peg$buildException(
				null,
				[{ type: "other", description: description }],
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function error(message) {
			throw peg$buildException(
				message,
				null,
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function peg$computePosDetails(pos) {
			var details = peg$posDetailsCache[pos],
					p, ch;

			if (details) {
				return details;
			} else {
				p = pos - 1;
				while (!peg$posDetailsCache[p]) {
					p--;
				}

				details = peg$posDetailsCache[p];
				details = {
					line:   details.line,
					column: details.column,
					seenCR: details.seenCR
				};

				while (p < pos) {
					ch = input.charAt(p);
					if (ch === "\n") {
						if (!details.seenCR) { details.line++; }
						details.column = 1;
						details.seenCR = false;
					} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
						details.line++;
						details.column = 1;
						details.seenCR = true;
					} else {
						details.column++;
						details.seenCR = false;
					}

					p++;
				}

				peg$posDetailsCache[pos] = details;
				return details;
			}
		}

		function peg$computeLocation(startPos, endPos) {
			var startPosDetails = peg$computePosDetails(startPos),
					endPosDetails   = peg$computePosDetails(endPos);

			return {
				start: {
					offset: startPos,
					line:   startPosDetails.line,
					column: startPosDetails.column
				},
				end: {
					offset: endPos,
					line:   endPosDetails.line,
					column: endPosDetails.column
				}
			};
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) { return; }

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildException(message, expected, found, location) {
			function cleanupExpected(expected) {
				var i = 1;

				expected.sort(function(a, b) {
					if (a.description < b.description) {
						return -1;
					} else if (a.description > b.description) {
						return 1;
					} else {
						return 0;
					}
				});

				while (i < expected.length) {
					if (expected[i - 1] === expected[i]) {
						expected.splice(i, 1);
					} else {
						i++;
					}
				}
			}

			function buildMessage(expected, found) {
				function stringEscape(s) {
					function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

					return s
						.replace(/\\/g,   '\\\\')
						.replace(/"/g,    '\\"')
						.replace(/\x08/g, '\\b')
						.replace(/\t/g,   '\\t')
						.replace(/\n/g,   '\\n')
						.replace(/\f/g,   '\\f')
						.replace(/\r/g,   '\\r')
						.replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
						.replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
						.replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
						.replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
				}

				var expectedDescs = new Array(expected.length),
						expectedDesc, foundDesc, i;

				for (i = 0; i < expected.length; i++) {
					expectedDescs[i] = expected[i].description;
				}

				expectedDesc = expected.length > 1
					? expectedDescs.slice(0, -1).join(", ")
							+ " or "
							+ expectedDescs[expected.length - 1]
					: expectedDescs[0];

				foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

				return "Expected " + expectedDesc + " but " + foundDesc + " found.";
			}

			if (expected !== null) {
				cleanupExpected(expected);
			}

			return new peg$SyntaxError(
				message !== null ? message : buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg$parsestart() {
			var s0, s1, s2, s3, s4;

			s0 = peg$currPos;
			s1 = peg$parseelement();
			if (s1 === peg$FAILED) {
				s1 = null;
			}
			if (s1 !== peg$FAILED) {
				s2 = peg$parsehash();
				if (s2 === peg$FAILED) {
					s2 = null;
				}
				if (s2 !== peg$FAILED) {
					s3 = [];
					s4 = peg$parseclass();
					if (s4 === peg$FAILED) {
						s4 = peg$parseattr();
						if (s4 === peg$FAILED) {
							s4 = peg$parsepseudo();
						}
					}
					while (s4 !== peg$FAILED) {
						s3.push(s4);
						s4 = peg$parseclass();
						if (s4 === peg$FAILED) {
							s4 = peg$parseattr();
							if (s4 === peg$FAILED) {
								s4 = peg$parsepseudo();
							}
						}
					}
					if (s3 !== peg$FAILED) {
						s1 = [s1, s2, s3];
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseelement() {
			var s0;

			if (input.charCodeAt(peg$currPos) === 42) {
				s0 = peg$c0;
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c1); }
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parseident();
			}

			return s0;
		}

		function peg$parseident() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$parsenmstart();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parsenmchar();
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parsenmchar();
				}
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c2(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parsehash() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 35) {
				s2 = peg$c3;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c4); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c5(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseclass() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c6;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c7); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c8(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseattr() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 91) {
				s2 = peg$c9;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c10); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				s4 = [];
				if (peg$c11.test(input.charAt(peg$currPos))) {
					s5 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c12); }
				}
				if (s5 !== peg$FAILED) {
					while (s5 !== peg$FAILED) {
						s4.push(s5);
						if (peg$c11.test(input.charAt(peg$currPos))) {
							s5 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c12); }
						}
					}
				} else {
					s4 = peg$FAILED;
				}
				if (s4 !== peg$FAILED) {
					peg$savedPos = s3;
					s4 = peg$c13(s4);
				}
				s3 = s4;
				if (s3 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 93) {
						s4 = peg$c14;
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c15); }
					}
					if (s4 !== peg$FAILED) {
						s2 = [s2, s3, s4];
						s1 = s2;
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c16(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsepseudo() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 58) {
				s2 = peg$c17;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c18); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parsefunction();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c19(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenmstart() {
			var s0;

			if (peg$c20.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c21); }
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsenmchar() {
			var s0;

			if (peg$c22.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c23); }
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsefunction() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = peg$parseident();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 40) {
					s3 = peg$c24;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c25); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parsebody();
					if (s4 !== peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 41) {
							s5 = peg$c26;
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c27); }
						}
						if (s5 !== peg$FAILED) {
							s2 = [s2, s3, s4, s5];
							s1 = s2;
						} else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c28(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsebody() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c29.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c30); }
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c29.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c30); }
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c13(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenonascii() {
			var s0;

			if (peg$c31.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c32); }
			}

			return s0;
		}

		function peg$parse_() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c33.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c34); }
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c33.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c34); }
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c35();
			}
			s0 = s1;

			return s0;
		}

		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		} else {
			if (peg$result !== peg$FAILED && peg$currPos < input.length) {
				peg$fail({ type: "end", description: "end of input" });
			}

			throw peg$buildException(
				null,
				peg$maxFailExpected,
				peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
				peg$maxFailPos < input.length
					? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
					: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
			);
		}
	}

	return {
		SyntaxError: peg$SyntaxError,
		parse:       peg$parse
	};
})();


/*
selector: HeaderComponent#header.class.other[myVal="someVal"]

returns an object like: 

[
	 "HeaderComponent",
	 "#header",
	 [
			".class",
			".other",
			"[myVal=\"someVal\"]"
	 ]
]

*/

function generateTag( selector ) {
	var parsed = peg.parse( selector );
	var string = '';

	var tagName;
	// first place in the object is the tag name
	if (parsed[0] === null) {
			// no el specified, default to div
			tagName = 'div';
			string += '<' + tagName;
	} else if ( typeof parsed[0] === 'string' ) {
		
		if (parsed[0][0].toUpperCase() === parsed[0][0]) {
			
			// if uppercase/PascalCase, it's a component
			console.log('component');
			return;
			// at this point we would evaluate the name as a component reference. the parent component would then apply this reference when it encounters a prop attribute with this key

		} else {
			// it's an element
			tagName = parsed[0];
			string += '<' + tagName;
		}
	}

	// second place in the object is the id
	if (parsed[1] !== null) {
		string += ' id="' + parsed[1].split('#')[1] + '"';
	}

	// third place could be classes or custom attributes (pseudo elements won't be supported, since we're generating elements, not selecting them)
	if (parsed[2].length) {
		
		var attrReg = /[a-z-]+/gi;

		classes = [];
		attrs = [];

		for (var p = 0; parsed[2].length > p; p++) {

			if (parsed[2][p].indexOf('.') > -1) {
				// if the string has a ., we will assume it's a css class
				var className = parsed[2][p].split('.')[1];
				classes.push( className );
			} 

			if (parsed[2][p].indexOf('[') > -1) {
				var attr = parsed[2][p];
				var attrKey = attr.match(attrReg)[0];
				var attrVal = attr.match(attrReg)[1];

				attr = attrKey + '="' + attrVal + '"';
				attrs.push(attr);
			}
		}

		if (classes.length) {
			classes = 'class="' + classes.join(' ') + '"';
			string += ' ' + classes;
		}

		if (attrs.length) {
			attrs = attrs.join(' ');
			string += ' ' + attrs;
		}
	}

	

	string += '></' + tagName + '>';

	return string;
}

template = {
	'#root': {
		'div': 'blah',
		'div': 'blah',
		'div': 'blah',
		'span': 'this is just a test template',
		'div#amazing.my-other-class': 'a series of nested elements…',
		'nav': {
			'span': 'this is a nested child'
		},
		'div': 'blah',
	}
}

// javascript doesn't do object literals with the same key name
// this might be rare in the day-to-day, but still a downer
// a workaround could be to wrap the container el that has multiple els of the same selector in an array, and turn the enclosing key/vals into objects

template = {
	'#root': [
		{ 'div': 'blah' },
		{ 'div': 'blah' },
		{ 'div': 'blah' },
		{ 'span': 'this is just a test template' },
		{ 'div#amazing.my-other-class': 'a series of nested elements…' },
		{ 'nav': {
			'span': 'this is a nested child'
		},
		{ 'div': 'blah' }
	]
};

function generateTemplateString( template ) {
	var $root;

	for (var prop in template) {
		$root = $( generateTag(prop) );

		var childKeys = Object.keys(template[prop]);
		
		if (childKeys.length) {

			for (var child in template[prop]) {

				if (typeof template[prop][child] === 'string') {
					var $child = $( generateTag(child) ).text( template[prop][child] )
					$root.append( $child );
				} else {
					console.log('got a nested object!', template[prop][child]);
					generateTemplateString( template[prop][child] );
				}

			}
		}
	}

	return $root;
}

function gen( obj ) {
	
	var $child;
	var children = [];

	for (var i = 0; Object.keys(obj).length > i; i++) {
		var child = Object.keys(obj)[i];
		
		if ( typeof obj[child] === 'string') {
			
			$child = $( generateTag(child) ).append( obj[child] );
		} else {

			$child = $( generateTag(child) );
			$child.append( gen( obj[child] ) );
		}

		children.push( $child );
	}

	// for (var child in obj) {
		
	// 	if (typeof obj[child] === 'string') {

	// 		$child = $( generateTag(child) ).append( obj[child] );

	// 	} else {
			
	// 		$child = $( generateTag(child) );
	// 		$child.append( gen( obj[child] ) );

	// 	}

		

	// }

	return children;
}

/*

* get this tag, set as root
	call yourself if these children( pass in this root )
		if children, attach children to root

		*/



