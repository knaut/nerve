peg = (function() {
	"use strict";

	/*
	 * Generated by PEG.js 0.9.0.
	 *
	 * http://pegjs.org/
	 */

	function peg$subclass(child, parent) {
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function peg$SyntaxError(message, expected, found, location) {
		this.message = message;
		this.expected = expected;
		this.found = found;
		this.location = location;
		this.name = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
			Error.captureStackTrace(this, peg$SyntaxError);
		}
	}

	peg$subclass(peg$SyntaxError, Error);

	function peg$parse(input) {
		var options = arguments.length > 1 ? arguments[1] : {},
			parser = this,

			peg$FAILED = {},

			peg$startRuleFunctions = {
				start: peg$parsestart
			},
			peg$startRuleFunction = peg$parsestart,

			peg$c0 = "*",
			peg$c1 = {
				type: "literal",
				value: "*",
				description: "\"*\""
			},
			peg$c2 = function(i, j) {
				return i + j.join('');
			},
			peg$c3 = "#",
			peg$c4 = {
				type: "literal",
				value: "#",
				description: "\"#\""
			},
			peg$c5 = function(h) {
				return h.join('');
			},
			peg$c6 = ".",
			peg$c7 = {
				type: "literal",
				value: ".",
				description: "\".\""
			},
			peg$c8 = function(c) {
				return c.join('');
			},
			peg$c9 = "[",
			peg$c10 = {
				type: "literal",
				value: "[",
				description: "\"[\""
			},
			peg$c11 = /^[^\]]/,
			peg$c12 = {
				type: "class",
				value: "[^\\]]",
				description: "[^\\]]"
			},
			peg$c13 = function(b) {
				return b.join('');
			},
			peg$c14 = "]",
			peg$c15 = {
				type: "literal",
				value: "]",
				description: "\"]\""
			},
			peg$c16 = function(a) {
				return a.join('');
			},
			peg$c17 = ":",
			peg$c18 = {
				type: "literal",
				value: ":",
				description: "\":\""
			},
			peg$c19 = function(p) {
				return p.join('');
			},
			peg$c20 = /^[a-z]/i,
			peg$c21 = {
				type: "class",
				value: "[a-z]i",
				description: "[a-z]i"
			},
			peg$c22 = /^[a-z0-9\-]/,
			peg$c23 = {
				type: "class",
				value: "[a-z0-9-]",
				description: "[a-z0-9-]"
			},
			peg$c24 = "(",
			peg$c25 = {
				type: "literal",
				value: "(",
				description: "\"(\""
			},
			peg$c26 = ")",
			peg$c27 = {
				type: "literal",
				value: ")",
				description: "\")\""
			},
			peg$c28 = function(f) {
				return f.join('');
			},
			peg$c29 = /^[^)]/,
			peg$c30 = {
				type: "class",
				value: "[^\\)]",
				description: "[^\\)]"
			},
			peg$c31 = /^[A-Z]/i,
			peg$c32 = {
				type: "class",
				value: "[A-Z]i",
				description: "[A-Z]i"
			},
			peg$c33 = /^[ \t\n\r]/,
			peg$c34 = {
				type: "class",
				value: "[ \\t\\n\\r]",
				description: "[ \\t\\n\\r]"
			},
			peg$c35 = function() {
				return '';
			},

			peg$currPos = 0,
			peg$savedPos = 0,
			peg$posDetailsCache = [{
				line: 1,
				column: 1,
				seenCR: false
			}],
			peg$maxFailPos = 0,
			peg$maxFailExpected = [],
			peg$silentFails = 0,

			peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$savedPos, peg$currPos);
		}

		function location() {
			return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description) {
			throw peg$buildException(
				null, [{
					type: "other",
					description: description
				}],
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function error(message) {
			throw peg$buildException(
				message,
				null,
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function peg$computePosDetails(pos) {
			var details = peg$posDetailsCache[pos],
				p, ch;

			if (details) {
				return details;
			} else {
				p = pos - 1;
				while (!peg$posDetailsCache[p]) {
					p--;
				}

				details = peg$posDetailsCache[p];
				details = {
					line: details.line,
					column: details.column,
					seenCR: details.seenCR
				};

				while (p < pos) {
					ch = input.charAt(p);
					if (ch === "\n") {
						if (!details.seenCR) {
							details.line++;
						}
						details.column = 1;
						details.seenCR = false;
					} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
						details.line++;
						details.column = 1;
						details.seenCR = true;
					} else {
						details.column++;
						details.seenCR = false;
					}

					p++;
				}

				peg$posDetailsCache[pos] = details;
				return details;
			}
		}

		function peg$computeLocation(startPos, endPos) {
			var startPosDetails = peg$computePosDetails(startPos),
				endPosDetails = peg$computePosDetails(endPos);

			return {
				start: {
					offset: startPos,
					line: startPosDetails.line,
					column: startPosDetails.column
				},
				end: {
					offset: endPos,
					line: endPosDetails.line,
					column: endPosDetails.column
				}
			};
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) {
				return;
			}

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildException(message, expected, found, location) {
			function cleanupExpected(expected) {
				var i = 1;

				expected.sort(function(a, b) {
					if (a.description < b.description) {
						return -1;
					} else if (a.description > b.description) {
						return 1;
					} else {
						return 0;
					}
				});

				while (i < expected.length) {
					if (expected[i - 1] === expected[i]) {
						expected.splice(i, 1);
					} else {
						i++;
					}
				}
			}

			function buildMessage(expected, found) {
				function stringEscape(s) {
					function hex(ch) {
						return ch.charCodeAt(0).toString(16).toUpperCase();
					}

					return s
						.replace(/\\/g, '\\\\')
						.replace(/"/g, '\\"')
						.replace(/\x08/g, '\\b')
						.replace(/\t/g, '\\t')
						.replace(/\n/g, '\\n')
						.replace(/\f/g, '\\f')
						.replace(/\r/g, '\\r')
						.replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
							return '\\x0' + hex(ch);
						})
						.replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
							return '\\x' + hex(ch);
						})
						.replace(/[\u0100-\u0FFF]/g, function(ch) {
							return '\\u0' + hex(ch);
						})
						.replace(/[\u1000-\uFFFF]/g, function(ch) {
							return '\\u' + hex(ch);
						});
				}

				var expectedDescs = new Array(expected.length),
					expectedDesc, foundDesc, i;

				for (i = 0; i < expected.length; i++) {
					expectedDescs[i] = expected[i].description;
				}

				expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

				foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

				return "Expected " + expectedDesc + " but " + foundDesc + " found.";
			}

			if (expected !== null) {
				cleanupExpected(expected);
			}

			return new peg$SyntaxError(
				message !== null ? message : buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg$parsestart() {
			var s0, s1, s2, s3, s4;

			s0 = peg$currPos;
			s1 = peg$parseelement();
			if (s1 === peg$FAILED) {
				s1 = null;
			}
			if (s1 !== peg$FAILED) {
				s2 = peg$parsehash();
				if (s2 === peg$FAILED) {
					s2 = null;
				}
				if (s2 !== peg$FAILED) {
					s3 = [];
					s4 = peg$parseclass();
					if (s4 === peg$FAILED) {
						s4 = peg$parseattr();
						if (s4 === peg$FAILED) {
							s4 = peg$parsepseudo();
						}
					}
					while (s4 !== peg$FAILED) {
						s3.push(s4);
						s4 = peg$parseclass();
						if (s4 === peg$FAILED) {
							s4 = peg$parseattr();
							if (s4 === peg$FAILED) {
								s4 = peg$parsepseudo();
							}
						}
					}
					if (s3 !== peg$FAILED) {
						s1 = [s1, s2, s3];
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseelement() {
			var s0;

			if (input.charCodeAt(peg$currPos) === 42) {
				s0 = peg$c0;
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c1);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parseident();
			}

			return s0;
		}

		function peg$parseident() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$parsenmstart();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parsenmchar();
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parsenmchar();
				}
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c2(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parsehash() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 35) {
				s2 = peg$c3;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c4);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c5(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseclass() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c6;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c7);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c8(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseattr() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 91) {
				s2 = peg$c9;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c10);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				s4 = [];
				if (peg$c11.test(input.charAt(peg$currPos))) {
					s5 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c12);
					}
				}
				if (s5 !== peg$FAILED) {
					while (s5 !== peg$FAILED) {
						s4.push(s5);
						if (peg$c11.test(input.charAt(peg$currPos))) {
							s5 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) {
								peg$fail(peg$c12);
							}
						}
					}
				} else {
					s4 = peg$FAILED;
				}
				if (s4 !== peg$FAILED) {
					peg$savedPos = s3;
					s4 = peg$c13(s4);
				}
				s3 = s4;
				if (s3 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 93) {
						s4 = peg$c14;
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c15);
						}
					}
					if (s4 !== peg$FAILED) {
						s2 = [s2, s3, s4];
						s1 = s2;
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c16(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsepseudo() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 58) {
				s2 = peg$c17;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c18);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parsefunction();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c19(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenmstart() {
			var s0;

			if (peg$c20.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c21);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsenmchar() {
			var s0;

			if (peg$c22.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c23);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsefunction() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = peg$parseident();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 40) {
					s3 = peg$c24;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c25);
					}
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parsebody();
					if (s4 !== peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 41) {
							s5 = peg$c26;
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) {
								peg$fail(peg$c27);
							}
						}
						if (s5 !== peg$FAILED) {
							s2 = [s2, s3, s4, s5];
							s1 = s2;
						} else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c28(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsebody() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c29.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c30);
				}
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c29.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c30);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c13(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenonascii() {
			var s0;

			if (peg$c31.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c32);
				}
			}

			return s0;
		}

		function peg$parse_() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c33.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c34);
				}
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c33.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c34);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c35();
			}
			s0 = s1;

			return s0;
		}

		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		} else {
			if (peg$result !== peg$FAILED && peg$currPos < input.length) {
				peg$fail({
					type: "end",
					description: "end of input"
				});
			}

			throw peg$buildException(
				null,
				peg$maxFailExpected,
				peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
				peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
			);
		}
	}

	return {
		SyntaxError: peg$SyntaxError,
		parse: peg$parse
	};
})();



// simple template
template = {
	'div.container': {
		'span.message': '{{message}}'
	}
}

// normalize an object into an array
template = {
	'#root': {
		'div': 'blah',
		'header': {
			'div#test': 'test',
			'div#blah': {
				'span#meh': 'blah blah'
			}
		},
		'span': 'this is just a test template',
		'div#amazing.my-other-class': 'a series of nested elements…',
		'nav': {
			'span': 'this is a nested child'
		},
		'footer#test': {
			'ul': {
				'li#test': 'span'
			}
		}
	}
}

// javascript doesn't do object literals with the same key name
// this might be rare in the day-to-day, but still a downer
// a workaround could be to wrap the container el that has multiple els of the same selector in an array, and turn the enclosing key/vals into objects
template2 = {
	'#root': [{
			'div': 'blah'
		}, {
			'div': 'blah'
		}, {
			'div': 'blah'
		}, {
			'span': 'this is just a test template'
		}, {
			'div#amazing.my-other-class': 'a series of nested elements…'
		}, {
			'nav': {
				'span': 'this is a nested child'
			}
		}, {
			'div': 'blah'
		},
		// nested arrays in arrays like this cause issues
		{
			'header': {
				'div#test': 'test',
				'div#blah': {
					'span#meh': 'blah blah'
				}
			}
		}, {
			'footer#test': {
				'ul': {
					'li#test': 'span'
				}
			}
		}
	]
};


testArr1 = {
	'#a.foo[data-val="1"][data-val="a"]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}],
	'#b.bar[data-val=2]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}],
	'#c.baz.banksy[data-val=3]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}]
}

testArr2 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'div#first': 'test text',
		'div#second': 'other text'
	},
	'#b.bar[data-val=2]': {
		'div#first': 'test text',
		'div#second': 'other text'
	},
	'#c.baz.banksy[data-val=3]': {
		'div#first': 'test text',
		'div#second': 'other text'
	}
}

testArr3 = {
	'#a.foo[data-val=1][data-val="a"]': [
		'div:test text',
		'div:other text'
	],
	'#b.bar[data-val=2]': [
		'div:test text',
		'div:other text'
	],
	'#c.baz.banksy[data-val=3]': [
		'div:test text',
		'div:other text'
	]
}

testArr4 = [{
	'#a.foo[data-val=1][data-val="a"]': [
		'div:test text',
		'div:other text'
	]
}, {
	'#b.bar[data-val=2]': [
		'div:test text',
		'div:other text'
	]
}, {
	'#c.baz.banksy[data-val=3]': [
		'div:test text',
		'div:other text'
	]
}]

// testArr5 = [
// 	'a#a.foo[data-val=1][data-val="a"]:test text'
// ]

// not supported
// testArr6 = 'span#a.foo[data-val=1][data-val="a"]:blah blah'

// not supported
// testArr7 = 'div'

testArr8 = [{
	'div': 'test'
}, {
	'div': 'test'
}]

testArr9 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		}
	}
}

testArr10 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		},

		'#d.bar[data-val=4]': {
			'#e.baz.banksy[data-val=5]': 'hello Waldo!'
		}
	}
}

testArr11 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		},

		'#d.bar[data-val=4]': {
			'#e.baz.banksy[data-val=5]': [{
					'div': 'blah'
				}, {
					'div': 'blah'
				}, {
					'div': 'blah'
				}, {
					'span': 'this is just a test template'
				}, {
					'div#amazing.my-other-class': 'a series of nested elements…'
				}, {
					'nav': {
						'span': 'this is a nested child'
					}
				}, {
					'div': 'blah'
				}
			]
		}
	}
}

parse = function(obj, key) {
	var tag = key; // css-like selector
	var inner = obj[key]; // innerHtml content
	// we rely on a generated peg parser for css selector parsing for now
	var parsed = peg.parse(key);

	// prepare to refine parsed classes and custom attrs
	if (parsed[0] === null) {
		parsed[0] = 'div';
	}
	var attrsClasses = parsed[2];
	var attrReg = /[\d\w\s-]+/gi;
	var classes = [];
	var attrs = [];

	for (var c = 0; attrsClasses.length > c; c++) {
		if (attrsClasses[c].indexOf('.') > -1) {
			// if the string has a ., we will assume it's a css class
			var className = attrsClasses[c].split('.')[1];
			classes.push(className);
		}

		if (attrsClasses[c].indexOf('[') > -1) {
			// assume attribute based on usual selector
			var attr = attrsClasses[c];
			var attrKey = attr.match(attrReg)[0];
			var attrVal = attr.match(attrReg)[1];

			// store the attribute as a map for string concat later
			var attrMap = {};
			attrMap[attrKey] = attrVal;
			attrs.push(attrMap);
		}
	}


	// preferring null over undefined
	if (inner === undefined) {
		// console.log(obj, key)
		inner = null;
	}

	// split id off the #
	var id = parsed[1];
	if (id) {
		id = id.split('#')[1];
	}

	// re-set the parsed var with a map of everything parsed
	parsed = {
		tagName: parsed[0],
		id: id,
		classes: classes,
		attrs: attrs,
		inner: inner
	}

	return parsed;
}

// recursively take a nested object where the keys are selectors
// and the vals are objects, arrays, or text nodes (strings)
// and normalize it into a consistently nested pattern of
// arrayed objects that map easily onto DOM nodes
normalize = function(struct) {

	// determine type at root level
	if (struct.hasOwnProperty('length')) {
		// console.log(struct, typeof struct)
		if (typeof struct === 'string') {
			var type = 'string';
		} else {
			var type = 'array';
		}
	} else {
		var type = 'object';
	}

	// normalize objects as arrays
	var normalized = [];

	if (type === 'object') {
		var keys = Object.keys(struct);

		for (var k = 0; keys.length > k; k++) {
			var obj = {};
			var key = keys[k];
			var val = struct[key];

			obj[key] = val;

			normalized.push(obj);
		}
	}

	if (type === 'array') {
		for (var a = 0; struct.length > a; a++) {
			var ai = struct[a];

			if (typeof ai === 'string') {
				var obj = {};
				var key = ai.split(/:/)[0];
				var val = ai.split(/:/)[1];

				obj[key] = val;

				normalized.push(obj);
			}

			if (typeof ai === 'object') {
				normalized.push(ai);
			}
		}
	}

	if (type === 'string') {
		// this could cause issues if there's a semi-colon in the inner text
		if (type.indexOf(':') === -1) {
			// console.log(normalized)
			normalized.push(struct);
		} else {
			var obj = {};
			var key = struct.split(/:/)[0];
			var val = struct.split(/:/)[1];

			obj[key] = val;

			normalized.push(obj);
		}

	}

	// scoping an array to push parsed objects to later
	var newStruct = [];

	if (type !== 'string') {

		// we loop through all structs at the root level
		for (var i = 0; normalized.length > i; i++) {

			var obj = normalized[i];

			// begin parsing process
			for (var key in obj) {

				// pass the normalized object to be parsed,
				// continue wiht the object we recieve
				var parsed = parse(obj, key)

				// unless its a string, we recurse over the nested
				// inner objects
				if (typeof parsed.inner !== 'string') {
					parsed.inner = normalize(parsed.inner);
				}
			}

			newStruct.push(parsed)
		}
	}

	// the final returned structure should be a normalized pattern,
	// where every tag's is an object whose inner content is either a 
	// plain string (text), null, or an array of one or more tags…
	return newStruct;

}

// take the normalized, nested array of objects and output a string that can
// be used as a template
stringify = function(normalized) {

	var string = '';
	var innerChildren = [];

	// iterate through the parsed object and
	// modify the string
	// console.log( typeof normalized, normalized )
	if (typeof normalized === 'string') return;
	
	for (var n = 0; normalized.length > n; n++) {

		var obj = normalized[n];

		string += '<' + obj.tagName;

		// id attribute
		if (obj.id) {
			string += ' id="' + obj.id + '"';
		}

		// class attributes
		if (obj.hasOwnProperty('classes') && obj.classes.length) {
			string += ' class="' + obj.classes.join(' ') + '"';
		}

		// custom attributes
		if (obj.hasOwnProperty('attrs') && obj.attrs.length) {
			// loop through array of key/vals
			for (var a = 0; obj.attrs.length > a; a++) {
				var attr = obj.attrs[a];
				for (var attrKey in attr) {
					string += ' ' + attrKey + '="' + attr[attrKey] + '"'
				}
			}
		}

		// end the root tag
		string += '>';

		if (obj.hasOwnProperty('inner') && obj.inner.length && typeof obj.inner !== 'string') {
			// console.log(obj)
			string += stringify(obj.inner);
		} else if (typeof obj.inner === 'string') {
			string += obj.inner;
		}

		string += '</' + obj.tagName + '>';

		// console.log(string)
	}

	return string;

}