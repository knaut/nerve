peg = (function() {
	"use strict";

	/*
	 * Generated by PEG.js 0.9.0.
	 *
	 * http://pegjs.org/
	 */

	function peg$subclass(child, parent) {
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function peg$SyntaxError(message, expected, found, location) {
		this.message = message;
		this.expected = expected;
		this.found = found;
		this.location = location;
		this.name = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
			Error.captureStackTrace(this, peg$SyntaxError);
		}
	}

	peg$subclass(peg$SyntaxError, Error);

	function peg$parse(input) {
		var options = arguments.length > 1 ? arguments[1] : {},
			parser = this,

			peg$FAILED = {},

			peg$startRuleFunctions = {
				start: peg$parsestart
			},
			peg$startRuleFunction = peg$parsestart,

			peg$c0 = "*",
			peg$c1 = {
				type: "literal",
				value: "*",
				description: "\"*\""
			},
			peg$c2 = function(i, j) {
				return i + j.join('');
			},
			peg$c3 = "#",
			peg$c4 = {
				type: "literal",
				value: "#",
				description: "\"#\""
			},
			peg$c5 = function(h) {
				return h.join('');
			},
			peg$c6 = ".",
			peg$c7 = {
				type: "literal",
				value: ".",
				description: "\".\""
			},
			peg$c8 = function(c) {
				return c.join('');
			},
			peg$c9 = "[",
			peg$c10 = {
				type: "literal",
				value: "[",
				description: "\"[\""
			},
			peg$c11 = /^[^\]]/,
			peg$c12 = {
				type: "class",
				value: "[^\\]]",
				description: "[^\\]]"
			},
			peg$c13 = function(b) {
				return b.join('');
			},
			peg$c14 = "]",
			peg$c15 = {
				type: "literal",
				value: "]",
				description: "\"]\""
			},
			peg$c16 = function(a) {
				return a.join('');
			},
			peg$c17 = ":",
			peg$c18 = {
				type: "literal",
				value: ":",
				description: "\":\""
			},
			peg$c19 = function(p) {
				return p.join('');
			},
			peg$c20 = /^[a-z]/i,
			peg$c21 = {
				type: "class",
				value: "[a-z]i",
				description: "[a-z]i"
			},
			peg$c22 = /^[a-z0-9\-]/,
			peg$c23 = {
				type: "class",
				value: "[a-z0-9-]",
				description: "[a-z0-9-]"
			},
			peg$c24 = "(",
			peg$c25 = {
				type: "literal",
				value: "(",
				description: "\"(\""
			},
			peg$c26 = ")",
			peg$c27 = {
				type: "literal",
				value: ")",
				description: "\")\""
			},
			peg$c28 = function(f) {
				return f.join('');
			},
			peg$c29 = /^[^)]/,
			peg$c30 = {
				type: "class",
				value: "[^\\)]",
				description: "[^\\)]"
			},
			peg$c31 = /^[A-Z]/i,
			peg$c32 = {
				type: "class",
				value: "[A-Z]i",
				description: "[A-Z]i"
			},
			peg$c33 = /^[ \t\n\r]/,
			peg$c34 = {
				type: "class",
				value: "[ \\t\\n\\r]",
				description: "[ \\t\\n\\r]"
			},
			peg$c35 = function() {
				return '';
			},

			peg$currPos = 0,
			peg$savedPos = 0,
			peg$posDetailsCache = [{
				line: 1,
				column: 1,
				seenCR: false
			}],
			peg$maxFailPos = 0,
			peg$maxFailExpected = [],
			peg$silentFails = 0,

			peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$savedPos, peg$currPos);
		}

		function location() {
			return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description) {
			throw peg$buildException(
				null, [{
					type: "other",
					description: description
				}],
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function error(message) {
			throw peg$buildException(
				message,
				null,
				input.substring(peg$savedPos, peg$currPos),
				peg$computeLocation(peg$savedPos, peg$currPos)
			);
		}

		function peg$computePosDetails(pos) {
			var details = peg$posDetailsCache[pos],
				p, ch;

			if (details) {
				return details;
			} else {
				p = pos - 1;
				while (!peg$posDetailsCache[p]) {
					p--;
				}

				details = peg$posDetailsCache[p];
				details = {
					line: details.line,
					column: details.column,
					seenCR: details.seenCR
				};

				while (p < pos) {
					ch = input.charAt(p);
					if (ch === "\n") {
						if (!details.seenCR) {
							details.line++;
						}
						details.column = 1;
						details.seenCR = false;
					} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
						details.line++;
						details.column = 1;
						details.seenCR = true;
					} else {
						details.column++;
						details.seenCR = false;
					}

					p++;
				}

				peg$posDetailsCache[pos] = details;
				return details;
			}
		}

		function peg$computeLocation(startPos, endPos) {
			var startPosDetails = peg$computePosDetails(startPos),
				endPosDetails = peg$computePosDetails(endPos);

			return {
				start: {
					offset: startPos,
					line: startPosDetails.line,
					column: startPosDetails.column
				},
				end: {
					offset: endPos,
					line: endPosDetails.line,
					column: endPosDetails.column
				}
			};
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) {
				return;
			}

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildException(message, expected, found, location) {
			function cleanupExpected(expected) {
				var i = 1;

				expected.sort(function(a, b) {
					if (a.description < b.description) {
						return -1;
					} else if (a.description > b.description) {
						return 1;
					} else {
						return 0;
					}
				});

				while (i < expected.length) {
					if (expected[i - 1] === expected[i]) {
						expected.splice(i, 1);
					} else {
						i++;
					}
				}
			}

			function buildMessage(expected, found) {
				function stringEscape(s) {
					function hex(ch) {
						return ch.charCodeAt(0).toString(16).toUpperCase();
					}

					return s
						.replace(/\\/g, '\\\\')
						.replace(/"/g, '\\"')
						.replace(/\x08/g, '\\b')
						.replace(/\t/g, '\\t')
						.replace(/\n/g, '\\n')
						.replace(/\f/g, '\\f')
						.replace(/\r/g, '\\r')
						.replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
							return '\\x0' + hex(ch);
						})
						.replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
							return '\\x' + hex(ch);
						})
						.replace(/[\u0100-\u0FFF]/g, function(ch) {
							return '\\u0' + hex(ch);
						})
						.replace(/[\u1000-\uFFFF]/g, function(ch) {
							return '\\u' + hex(ch);
						});
				}

				var expectedDescs = new Array(expected.length),
					expectedDesc, foundDesc, i;

				for (i = 0; i < expected.length; i++) {
					expectedDescs[i] = expected[i].description;
				}

				expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

				foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

				return "Expected " + expectedDesc + " but " + foundDesc + " found.";
			}

			if (expected !== null) {
				cleanupExpected(expected);
			}

			return new peg$SyntaxError(
				message !== null ? message : buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg$parsestart() {
			var s0, s1, s2, s3, s4;

			s0 = peg$currPos;
			s1 = peg$parseelement();
			if (s1 === peg$FAILED) {
				s1 = null;
			}
			if (s1 !== peg$FAILED) {
				s2 = peg$parsehash();
				if (s2 === peg$FAILED) {
					s2 = null;
				}
				if (s2 !== peg$FAILED) {
					s3 = [];
					s4 = peg$parseclass();
					if (s4 === peg$FAILED) {
						s4 = peg$parseattr();
						if (s4 === peg$FAILED) {
							s4 = peg$parsepseudo();
						}
					}
					while (s4 !== peg$FAILED) {
						s3.push(s4);
						s4 = peg$parseclass();
						if (s4 === peg$FAILED) {
							s4 = peg$parseattr();
							if (s4 === peg$FAILED) {
								s4 = peg$parsepseudo();
							}
						}
					}
					if (s3 !== peg$FAILED) {
						s1 = [s1, s2, s3];
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parseelement() {
			var s0;

			if (input.charCodeAt(peg$currPos) === 42) {
				s0 = peg$c0;
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c1);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parseident();
			}

			return s0;
		}

		function peg$parseident() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$parsenmstart();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parsenmchar();
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parsenmchar();
				}
				if (s2 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c2(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}

			return s0;
		}

		function peg$parsehash() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 35) {
				s2 = peg$c3;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c4);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c5(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseclass() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c6;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c7);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseident();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c8(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parseattr() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 91) {
				s2 = peg$c9;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c10);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				s4 = [];
				if (peg$c11.test(input.charAt(peg$currPos))) {
					s5 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c12);
					}
				}
				if (s5 !== peg$FAILED) {
					while (s5 !== peg$FAILED) {
						s4.push(s5);
						if (peg$c11.test(input.charAt(peg$currPos))) {
							s5 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) {
								peg$fail(peg$c12);
							}
						}
					}
				} else {
					s4 = peg$FAILED;
				}
				if (s4 !== peg$FAILED) {
					peg$savedPos = s3;
					s4 = peg$c13(s4);
				}
				s3 = s4;
				if (s3 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 93) {
						s4 = peg$c14;
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c15);
						}
					}
					if (s4 !== peg$FAILED) {
						s2 = [s2, s3, s4];
						s1 = s2;
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c16(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsepseudo() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = peg$currPos;
			if (input.charCodeAt(peg$currPos) === 58) {
				s2 = peg$c17;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c18);
				}
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parsefunction();
				if (s3 !== peg$FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c19(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenmstart() {
			var s0;

			if (peg$c20.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c21);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsenmchar() {
			var s0;

			if (peg$c22.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c23);
				}
			}
			if (s0 === peg$FAILED) {
				s0 = peg$parsenonascii();
			}

			return s0;
		}

		function peg$parsefunction() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$currPos;
			s2 = peg$parseident();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 40) {
					s3 = peg$c24;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) {
						peg$fail(peg$c25);
					}
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parsebody();
					if (s4 !== peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 41) {
							s5 = peg$c26;
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) {
								peg$fail(peg$c27);
							}
						}
						if (s5 !== peg$FAILED) {
							s2 = [s2, s3, s4, s5];
							s1 = s2;
						} else {
							peg$currPos = s1;
							s1 = peg$FAILED;
						}
					} else {
						peg$currPos = s1;
						s1 = peg$FAILED;
					}
				} else {
					peg$currPos = s1;
					s1 = peg$FAILED;
				}
			} else {
				peg$currPos = s1;
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c28(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsebody() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c29.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c30);
				}
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c29.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c30);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c13(s1);
			}
			s0 = s1;

			return s0;
		}

		function peg$parsenonascii() {
			var s0;

			if (peg$c31.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c32);
				}
			}

			return s0;
		}

		function peg$parse_() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			if (peg$c33.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) {
					peg$fail(peg$c34);
				}
			}
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					if (peg$c33.test(input.charAt(peg$currPos))) {
						s2 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s2 = peg$FAILED;
						if (peg$silentFails === 0) {
							peg$fail(peg$c34);
						}
					}
				}
			} else {
				s1 = peg$FAILED;
			}
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c35();
			}
			s0 = s1;

			return s0;
		}

		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		} else {
			if (peg$result !== peg$FAILED && peg$currPos < input.length) {
				peg$fail({
					type: "end",
					description: "end of input"
				});
			}

			throw peg$buildException(
				null,
				peg$maxFailExpected,
				peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
				peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
			);
		}
	}

	return {
		SyntaxError: peg$SyntaxError,
		parse: peg$parse
	};
})();



// simple template
template = {
	'div.container': {
		'span.message': '{{message}}'
	}
}

// normalize an object into an array
template = {
	'#root': {
		'div': 'blah',
		'header': {
			'div#test': 'test',
			'div#blah': {
				'span#meh': 'blah blah'
			}
		},
		'span': 'this is just a test template',
		'div#amazing.my-other-class': 'a series of nested elements…',
		'nav': {
			'span': 'this is a nested child'
		},
		'footer#test': {
			'ul': {
				'li#test': 'span'
			}
		}
	}
}

// javascript doesn't do object literals with the same key name
// this might be rare in the day-to-day, but still a downer
// a workaround could be to wrap the container el that has multiple els of the same selector in an array, and turn the enclosing key/vals into objects
template2 = {
	'#root': [{
			'div': 'blah'
		}, {
			'div': 'blah'
		}, {
			'div': 'blah'
		}, {
			'span': 'this is just a test template'
		}, {
			'div#amazing.my-other-class': 'a series of nested elements…'
		}, {
			'nav': {
				'span': 'this is a nested child'
			}
		}, {
			'div': 'blah'
		},
		// nested arrays in arrays like this cause issues
		{
			'header': {
				'div#test': 'test',
				'div#blah': {
					'span#meh': 'blah blah'
				}
			}
		}, {
			'footer#test': {
				'ul': {
					'li#test': 'span'
				}
			}
		}
	]
};


testArr1 = {
	'#a.foo[data-val="1"][data-val="a"]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}],
	'#b.bar[data-val=2]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}],
	'#c.baz.banksy[data-val=3]': [{
		'div': 'test text'
	}, {
		'div': 'other text'
	}]
}


testArr2 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'div#first': 'test text',
		'div#second': 'other text'
	},
	'#b.bar[data-val=2]': {
		'div#first': 'test text',
		'div#second': 'other text'
	},
	'#c.baz.banksy[data-val=3]': {
		'div#first': 'test text',
		'div#second': 'other text'
	}
}

// placing literal strings in arrays, delimited by :
testArr3 = {
	'#a.foo[data-val=1][data-val="a"]': [
		'div:test text',
		'div:other text'
	],
	'#b.bar[data-val=2]': [
		'div:test text',
		'div:other text'
	],
	'#c.baz.banksy[data-val=3]': [
		'div:test text',
		'div:other text'
	]
}

// nest objects in arrays
testArr4 = [{
	'#a.foo[data-val=1][data-val="a"]': [
		'div:test text',
		'div:other text'
	]
}, {
	'#b.bar[data-val=2]': [
		'div:test text',
		'div:other text'
	]
}, {
	'#c.baz.banksy[data-val=3]': [
		'div:test text',
		'div:other text'
	]
}]

// testArr5 = [
// 	'a#a.foo[data-val=1][data-val="a"]:test text'
// ]

// not supported
// testArr6 = 'span#a.foo[data-val=1][data-val="a"]:blah blah'

// not supported
// testArr7 = 'div'

testArr8 = [{
	'div': 'test'
}, {
	'div': 'test'
}]

testArr9 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		}
	}
}

testArr10 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		},

		'#d.bar[data-val=4]': {
			'#e.baz.banksy[data-val=5]': 'hello Waldo!'
		}
	}
}

testArr11 = {
	'#a.foo[data-val=1][data-val="a"]': {
		'#b.bar[data-val=2]': {
			'#c.baz.banksy[data-val=3]': 'hello World!'
		},

		'#d.bar[data-val=4]': {
			'#e.baz.banksy[data-val=5]': [{
					'div': 'blah'
				}, {
					'div': 'blah'
				}, {
					'div': 'blah'
				}, {
					'span': 'this is just a test template'
				}, {
					'div#amazing.my-other-class': 'a series of nested elements…'
				}, {
					'nav': {
						'span': 'this is a nested child'
					}
				}, {
					'div': 'blah'
				}
			]
		}
	}
}

// testing function templates
tf1 = {
	'div#tf1': {
		'span': function() {
			if (data.message) {
				return {
					div: '{{message}}'
				}
			} else {
				return {
					span: 'im not sure what im doing'
				}
			}
		}
	}
}

tf1 = {
	'div#tf1': {
		'span': function() {
			if (data.message) {
				{{message}}
			} else {
				'im not sure what im doing'
			}
		}
	}
}

tf2 = {
	'div#tf2': function() {
		return {
			span: 'test text'
		}
	}
}

tf3 = {
	'div#tf3': function( data ) {
		if (data) { 
			return {
				span: 'this is {{data}}'
			}
		} else {
			return {
				span: 'not sure'
			}
		}
	}
}

// in context, function args wouldn't mean much here, because their bodies
// would be used by underscore during template rendering. these functions never get called,
// they are just inlaid into the template
tf4 = {
	'div#tf3': function() {
		if (message) { 
			return {
				span: 'this is {{message}}'
			}
		} else {
			return {
				span: 'not sure'
			}
		}
	}
}

// you could re-render the function
testReturn = '<div>{{ (function( data ) { return \'<span>:{{data}}:</span>\'})( data ) }}</div>'

// but thats a stretch from this
testReturn2 = '<div><< if (message) { >><span></span><< } else { >>bob<< } >></div>'

// working based on test return 2
// a = template(testReturn2)({message: 'test'})
// yields "<div><< if (message) { >><span></span><< } else { >>bob<< } >></div>"

// need a better syntax than tildes
// annoying, but we split strings based on familiar tokens, which often happen to be ones we use later
// would be nice to configure template (and thus parsing) settings based on a single config -- problem for later
tr2 = {
	'div.blah': function() {
		if (message) {
			return {
				span: '~~message~~'
			}
		} else {
			return {
				span: 'bob'
			}
		}
	}
}

// playing with custom syntaxes
// these are the most visually boring, but also the simplest and easiest to write
c1 = {
	'#tf3': {
		'if message': {
			span: 'this is {{message}}'
		},
		'else': {
			'#bob': 'bob'
		}
	}
}

c2 = {
	'#tf3': {
		'for item in myArray': {
			span: 'this is {{message}}'
		}
	}
}

c3 = {
	'#c3': {
		'for item in myArray': {
			'if item !== undefined': {
				span: 'this is my {{item}}'
			}
		}
	}
}

// () keep it simple *?

// d1 = {
// 	'#d1': {
// 		'for': function(item in array) {
// 			'if (item !== undefined)': {
// 				span: 'this is my {{item}}'
// 			}
// 		}
// 	}
// }

// just straight inline javascript
d2 = {
	'#d2': {
		'for (var item in array)': {
			'if (item !== undefined)': {
				span: 'this is my {{item}}'
			}
		}
	}
}
// or really use them like helpers/functions
d3 = {
	'#d3': {
		forEach: function(index, array) {
			if (index !== undefined) {
				return {
					span: 'this is some {{item}}'
				}
			}
		},
		ifElse: function() {}
	}
}

d4 = {
	'#d4': {
		forEach: function(index, array) {
			if (index !== undefined) {
				return {
					span: 'this is some {{item}}'
				}
			}
		},
		ifElse: function( someItem ) {
			if (someItem !== undefined) {
				return {
					span: 'what is this {{someItem}}'
				}
			}
		}
	}
}

// or try to hack the system with the usually suspected strings
// d5 = {
// 	'#d5': {
// 		'<< for (var prop in item) { >>': {
// 			span: '{{item}}'
// 		}
// 	}
// }





parse = function(obj, key) {
	var tag = key; // css-like selector
	var inner = obj[key]; // innerHtml content
	// we rely on a generated peg parser for css selector parsing for now
	var parsed = peg.parse(key);

	// prepare to refine parsed classes and custom attrs
	if (parsed[0] === null) {
		parsed[0] = 'div';
	}
	var attrsClasses = parsed[2];
	var attrReg = /[\d\w\s-]+/gi;
	var classes = [];
	var attrs = [];

	for (var c = 0; attrsClasses.length > c; c++) {
		if (attrsClasses[c].indexOf('.') > -1) {
			// if the string has a ., we will assume it's a css class
			var className = attrsClasses[c].split('.')[1];
			classes.push(className);
		}

		if (attrsClasses[c].indexOf('[') > -1) {
			// assume attribute based on usual selector
			var attr = attrsClasses[c];
			var attrKey = attr.match(attrReg)[0];
			var attrVal = attr.match(attrReg)[1];

			// store the attribute as a map for string concat later
			var attrMap = {};
			attrMap[attrKey] = attrVal;
			attrs.push(attrMap);
		}
	}


	// preferring null over undefined
	if (inner === undefined) {
		// console.log(obj, key)
		inner = null;
	}

	// split id off the #
	var id = parsed[1];
	if (id) {
		id = id.split('#')[1];
	}

	// re-set the parsed var with a map of everything parsed
	parsed = {
		tagName: parsed[0],
		id: id,
		classes: classes,
		attrs: attrs,
		inner: inner
	}

	return parsed;
}

// recursively take a nested object where the keys are selectors
// and the vals are objects, arrays, or text nodes (strings)
// and normalize it into a consistently nested pattern of
// arrayed objects that map easily onto DOM nodes
normalize = function(struct) {

	// determine type at root level
	if (struct.hasOwnProperty('length')) {
		// console.log(struct, typeof struct)
		if (typeof struct === 'string') {
			var type = 'string';
		} else {
			if (typeof struct.push === 'function') {
				var type = 'array';
			} else {
				var type = 'function';	
			}
		}
	} else {
		var type = 'object';
	}

	// console.log(typeof struct, struct);

	// normalize objects as arrays
	var normalized = [];

	if (type === 'object') {
		var keys = Object.keys(struct);

		for (var k = 0; keys.length > k; k++) {
			var obj = {};
			var key = keys[k];
			var val = struct[key];

			obj[key] = val;

			normalized.push(obj);
		}
	}

	if (type === 'array') {
		for (var a = 0; struct.length > a; a++) {
			var ai = struct[a];

			if (typeof ai === 'string') {
				var obj = {};
				var key = ai.split(/:/)[0];
				var val = ai.split(/:/)[1];

				obj[key] = val;

				normalized.push(obj);
			}

			if (typeof ai === 'object') {
				normalized.push(ai);
			}
		}
	}

	if (type === 'string') {
		// this could cause issues if there's a semi-colon in the inner text
		if (type.indexOf(':') === -1) {
			// console.log(normalized)
			normalized.push(struct);
		} else {
			var obj = {};
			var key = struct.split(/:/)[0];
			var val = struct.split(/:/)[1];

			obj[key] = val;

			normalized.push(obj);
		}
	}

	if (type === 'function') {
		var funcHead = /^function\s*[(][)]\s*[{]\s*/;	// eg 'function() { …'
		var funcTail = /\s*[}]{1}\s*$/;		// eg last } bracket of the function
		var funcReturns = /return\s*/;
		var src = struct.toString();
		
		normalized.push( normalizeFunction( src ) );

		console.log(normalized);

	}

	// scoping an array to push parsed objects to later
	var newStruct = [];

	if (type !== 'string') {

		// we loop through all structs at the root level
		for (var i = 0; normalized.length > i; i++) {

			var obj = normalized[i];

			// begin parsing process
			for (var key in obj) {

				// pass the normalized object to be parsed,
				// continue with the object we recieve
				// console.log(key)
				var parsed = parse(obj, key)

				// unless its a string, we recurse over the nested
				// inner objects

				if (typeof parsed.inner !== 'string') {

					parsed.inner = normalize(parsed.inner);	
					
				}
			}

			newStruct.push(parsed)
		}
	}

	// the final returned structure should be a normalized pattern,
	// where every tag's is an object whose inner content is either a 
	// plain string (text), null, or an array of one or more tags…
	return newStruct;

}

// take the normalized, nested array of objects and output a string that can
// be used as a template
stringify = function(normalized) {

	var string = '';
	var innerChildren = [];

	// iterate through the parsed object and
	// modify the string
	// console.log( typeof normalized, normalized )
	if (typeof normalized === 'string') return;
	
	for (var n = 0; normalized.length > n; n++) {

		var obj = normalized[n];

		string += '<' + obj.tagName;

		// id attribute
		if (obj.id) {
			string += ' id="' + obj.id + '"';
		}

		// class attributes
		if (obj.hasOwnProperty('classes') && obj.classes.length) {
			string += ' class="' + obj.classes.join(' ') + '"';
		}

		// custom attributes
		if (obj.hasOwnProperty('attrs') && obj.attrs.length) {
			// loop through array of key/vals
			for (var a = 0; obj.attrs.length > a; a++) {
				var attr = obj.attrs[a];
				for (var attrKey in attr) {
					string += ' ' + attrKey + '="' + attr[attrKey] + '"'
				}
			}
		}

		// end the root tag
		string += '>';

		if (obj.hasOwnProperty('inner') && obj.inner.length && typeof obj.inner !== 'string') {
			// console.log(obj)
			string += stringify(obj.inner);
		} else if (typeof obj.inner === 'string') {
			string += obj.inner;
		}

		string += '</' + obj.tagName + '>';

		// console.log(string)
	}

	return string;

}


// By default, Underscore uses ERB-style template delimiters, change the
// following template settings to use alternative delimiters.

_ = {}

templateSettings = {
	interpolate: /\~\~(.+?)\~\~/g,
	escape: /\-\-(.+?)\-\-/g,
	evaluate: /\<\<(.+?)\>\>/g
}

// When customizing `templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
	"'": "'",
	'\\': '\\',
	'\r': 'r',
	'\n': 'n',
	'\u2028': 'u2028',
	'\u2029': 'u2029'
};
var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
var escapeChar = function(match) {
	return '\\' + escapes[match];
};

normalizeFunction = function( func ) {
	rgfuncHead = /^function\s*[(][)]\s*[{]\s*/;	// eg 'function() { …'
	rgfuncTail = /\s*[}]{1}\s*$/;		// eg last } bracket of the function
	rgfuncReturns = /return\s*/;

	var keyword = 'return';		// the string we look for when parsing return blocks

	var src = func.toString();
	src = src.split( src.match(rgfuncHead) )[1];
	src = src.split( src.match(rgfuncTail) )[0];

	var splitSrc = src.split('return');

	var srcHead = splitSrc[0];
	var srcBody = splitSrc;
	srcBody.shift();

	// loop through the function body and parse the return blocks
	// we skip the first item, which is the src head

	var parsedReturnBlocks = [];
	var slicedReturnBlocks = [];
	for (var i = 0; srcBody.length > i; i++) {
		var trimmedSrcBody = srcBody[i].replace(/\s/g, "");
		slicedReturnBlocks.push( sliceReturnBlock( trimmedSrcBody ) );
		parsedReturnBlocks.push( parseReturnBlock( trimmedSrcBody ) );
	}

	var normalizedReturnBlocks = normalize(parsedReturnBlocks);

	// normalized return blocks are inner properties of code blocks
	var script = func.toString();
	// lose the whitespace
	script = script.replace(/\s/g, "");
	script = script.split( rgfuncHead )[1];
	script = script.split( rgfuncTail )[0];

	for ( var n = 0; slicedReturnBlocks.length > n; n++) {
		script = script.replace( keyword + slicedReturnBlocks[n] , '%break%' );
	}

	var parsedFunc = {
		tagName: 'function',
		src: script,
		inner: parsedReturnBlocks
	}

	return parsedFunc;
}

// separate the return block from the rest of the code and return it
sliceReturnBlock = function( string ) {
	var enterBracesInt = 0;
	var exitBracesInt = 0;
	var sliceLength = 0;
	
	// cut out the object by finding when its number of opening/closing braces match
	for (var i = 0; string.length > i; i++) {
		if (string[i] === '{') {
			enterBracesInt++;
		}
		if (string[i] === '}') {
			exitBracesInt++;
		}
		if (enterBracesInt === exitBracesInt) {
			sliceLength = i + 1;	// need an extra increment to catch the ending brace
			break;
		}
	}
	
	var slicedString = string.slice(0, sliceLength);
	
	return slicedString;
}

// take the return block as a string and return an object that can be normalized
parseReturnBlock = function( string ) {
	var slicedString = sliceReturnBlock(string);
	slicedString = slicedString.replace('{', '');
	slicedString = slicedString.replace('}', '');

	var props = slicedString.split(',');
	var obj = {};

	for (var p = 0; props.length > p; p++) {
		var pair = props[p].split(':');
		pair[1] = pair[1].replace(/'*/g, "");
		obj[pair[0]] = pair[1];
	}

	return obj;
}

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
template = function(text, settings, oldSettings) {
	if (!settings && oldSettings) settings = oldSettings;
	settings = templateSettings;
	
	// Combine delimiters into one regular expression via alternation.
	var matcher = RegExp([
		(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source
	].join('|') + '|$', 'g');
	
	// Compile the template source, escaping string literals appropriately.
	var index = 0;
	var source = "__p+='";
	text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
		source += text.slice(index, offset).replace(escaper, escapeChar);
		index = offset + match.length;
		if (escape) {
			source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
		} else if (interpolate) {
			source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
		} else if (evaluate) {
			source += "';\n" + evaluate + "\n__p+='";
		}
		// Adobe VMs need the match returned to produce the correct offest.
		return match;
	});
	source += "';\n";
	
	// If a variable is not specified, place data values in local scope.
	if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	source = "var __t,__p='',__j=Array.prototype.join," +
		"print=function(){__p+=__j.call(arguments,'');};\n" +
		source + 'return __p;\n';
	try {
		var render = new Function(settings.variable || 'obj', '_', source);
	} catch (e) {
		e.source = source;
		throw e;
	}
	var template = function(data) {
		return render.call(this, data, _);
	};
	
	// Provide the compiled source as a convenience for precompilation.
	var argument = settings.variable || 'obj';
	template.source = 'function(' + argument + '){\n' + source + '}';
	return template;
}
















